require Math;
require Slavr;

function String statistics(Ref<Slavr> slavr) {
  String sout = '\nSlavr has\n';
  sout += 'Preloaded: ' + slavr.preloadInstances.size() + '\n';
  sout += 'Instances: ' + slavr.scene.instances.size() + '\n';
  sout += 'Materials: ' + slavr.scene.materials.size() + '\n';
  sout += 'Lights: ' + slavr.scene.lights.size() + '\n';
  sout += 'Scene has: ';
  sout += 'MaterialsRef: ' + slavr.scene.materialsRef.size() + '\n';
  sout += 'Lut: ' + slavr.scene.lut.size() + '\n';
  sout += 'Bboxs: ' + slavr.scene.bboxs.size() + '\n';
  sout += 'Versions: ' + slavr.scene.versions.size() + '\n';
  sout += 'Dirty: ' + slavr.scene.dirty + '\n';
  sout += 'Lock: ' + slavr.scene.lock + '\n';
  return sout;

}

/// helper function to draw a VDBVolume
/// \dfgPresetCreate
/// \dfgPresetDefault scattering {"r": 0.6, "g": 0.9, "b": 0.9, "a": 1.0}
/// \dfgPresetDefault absorption {"r": 0.7, "g": 0.7, "b": 0.7, "a": 1.0}
/// \dfgPresetDefault primaryStep 1.0
/// \dfgPresetDefault secondaryStep 3.0
function DrawingHandle.drawVolumeVDB!(io SlavrViewport sViewport, String name, Color scattering, Color absorption, Float32 primaryStep, Float32 secondaryStep, Xfo transforms[], VDBVolumes volume, Boolean active, Boolean doubleSided, out Vec3 dummyResult, out InlineInstance instance)
{
  String uidName = this.uid() + '_' + name;
  report("drawVolumeVDB start: "+uidName);


  InlineDrawing draw = this.getDrawing();
  if(draw.getShapeAdaptorIndex("InlineVDBVolumesShape") == -1)draw.registerShapeAdaptor(OGLVDBVolumesShapeAdaptor());
  SlavrMediumShader volumeShader = draw.registerShader(SlavrMediumShader(uidName,OGLFloatGridVertexSS()));
  InlineVDBVolumesShape volumeShape = draw.getShape(uidName);
  if(volumeShape == null){
    report("drawVolumeVDB registering new shape");
    volumeShape = draw.registerShape(InlineVDBVolumesShape(uidName, volume));
  }

  // if(volumeShape != null)
  //   volumeShape.setMesh(mesh);


  // SlavrVolumeMaterial volumeMaterialSlavr =
  //     volumeShader.getOrCreateSlavrMaterial(SlavrVolumeMaterial());
  // volumeMaterialSlavr.setScattering(scattering);
  // volumeMaterialSlavr.setAbsorption(absorption);
  // volumeMaterialSlavr.setPrimaryStep(primaryStep);
  // volumeMaterialSlavr.setShadowStep(secondaryStep);



  // InlineShader shader = volumeShader;
  // InlineMaterial volumeMaterial = this.drawShapeInstances(name, volumeShader, transforms, volumeShape, dummyResult, instance);



  // InlineMaterial volumeMaterial = shader.getOrCreateMaterial(uidName);
  SlavrVolumeMaterial volumeMaterialSlavr = volumeShader.getOrCreateSlavrMaterial(SlavrVolumeMaterial(uidName));
  volumeMaterialSlavr.setScattering(scattering);
  volumeMaterialSlavr.setAbsorption(absorption);
  volumeMaterialSlavr.setPrimaryStep(primaryStep);
  volumeMaterialSlavr.setShadowStep(secondaryStep);
  // volumeMaterialSlavr.material.setActive(active);

  StaticInlineTransform xform = this.rootTransform.getChild(uidName);
  if(xform == null)
  {
    // report("drawVolumeVDB: "+"creating new volume instance from dfgHelper");
    xform = StaticInlineTransform(uidName);
    this.rootTransform.addChild(xform);
    InlineMaterial volumeMaterial = volumeMaterialSlavr.material;
    instance = SimpleInlineInstance(uidName, xform, volumeShape, volumeMaterial);
    Ref<InlineInstance> instance_ref = instance;
    sViewport.addGeometryInstance(instance_ref);
    volumeMaterial.setUniform('u_screenWidth', 12.5f);
    volumeMaterial.setUniform('u_vertexMult', 3.0f);
    volumeMaterial.setUniform('u_levelSet', Integer(false));
    volumeMaterial.setUniform('u_mapMinMax', 0);
  }

  if(xform)
  {
    // report("drawVolumeVDB: "+"modifying transforms instance from dfgHelper");
    xform.setLocalCount(transforms.size());
    for(Size i=0;i<transforms.size();i++)
      xform.setLocalXfo(i, transforms[i]);
  }

  // report("drawVolumeVDB end: "+uidName);
}

/// helper function to draw a VDBVolume
/// \dfgPresetCreate
/// \dfgPresetDefault scattering {"r": 0.6, "g": 0.9, "b": 0.9, "a": 1.0}
/// \dfgPresetDefault absorption {"r": 0.7, "g": 0.7, "b": 0.7, "a": 1.0}
/// \dfgPresetDefault primaryStep 1.0
/// \dfgPresetDefault secondaryStep 3.0
function DrawingHandle.drawVolumeVDB!(io SlavrViewport sViewport, String name, Color scattering, Color absorption, Float32 primaryStep, Float32 secondaryStep, Xfo transform, VDBVolumes volume, Boolean active, Boolean doubleSided, out Vec3 dummyResult, out InlineInstance instance)
{
  Xfo transforms[];
  transforms.push(transform);
  this.drawVolumeVDB(sViewport, name, scattering, absorption, primaryStep, secondaryStep, transforms, volume, active, doubleSided, dummyResult, instance);
}



